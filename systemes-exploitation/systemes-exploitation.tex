\documentclass[french, toc]{../cs-classes/cs-classes}

\title{Systèmes d'exploitation}
\author{Timothy Bourke, Marc Pouzet\\ Notes par Antoine Groudiev}
\date{Version du \today}

\begin{document}
\newpage
\section*{Introduction}
Ce document est l'ensemble non officiel des notes du cours \emph{Systèmes d'exploitation} du Département Informatique de l'ENS Ulm. Elles sont librement inspirés des notes de cours sous forme de présentation rédigées par Timothy Bourke et Marc Pouzet.

\section{Micro-noyau}
Commençons ce cours par la programmation d'un micro-noyau fortement simplifié, implémenté en OCaml. Notre objectif sera de retenir l'essentiel d'un noyau de système classique, en exécutant le moins de fonctions possibles en mode super-utilisateur\footnote{Les fonctions exécutées en mode "super-utilisateur" ont un accès non protégé aux ressources.}.

\subsection{Description générale d'un micro-noyau}
Un micro-noyau contient une ou plusieurs \emph{applications}, comme un système de fichier ou un driver de disque.

Les principales fonctionnalités d'un micro-noyau sont de gérer les processus, la communication entre eux, et la mémoire virtuelle. Il doit être capable de créer, arrêter, ordonner les processus en fonction de leur priorité.

On se donne les caractéristiques suivantes pour l'architecture machine:
\begin{itemize}
    \item elle est capable d'exécuter un seul processus à la fois
    \item elle possède cinq registres, de \texttt{r0} à \texttt{r4}
\end{itemize}

\subsection{Appels système}
Le micro-noyau doit être capable de réagir à deux types d'évènements:
\begin{itemize}
    \item l'interruption d'un compteur de temps (\texttt{timer})
    \item des interruptions logicielles (\texttt{system trap} ou \texttt{software interrupt})
\end{itemize}
Les processus de l'utilisateur peuvent changer le contenu des registres et générer des appels système arbitraires. Quand un appel système est déclenché, le micro-noyau lit le contenu des registres pour déterminer l’appel effectué et les arguments de cet appel. Il réagit en effectuant l’appel (par exemple, la mise à jour de l’état du système) et en plaçant les valeurs de retour dans les registres.

On définit les codes d'appels systèmes suivants:
\begin{figure}[!ht]
    \centering
    \begin{tabular}{c c}
        Registre \texttt{r0} & Appel système \\
        \hline
        \texttt{0} & \texttt{new\_channel} \\
        \texttt{1} & \texttt{send} \\
        \texttt{2} & \texttt{receive} \\
        \texttt{3} & \texttt{fork} \\
        \texttt{4} & \texttt{exit} \\
        \texttt{5} & \texttt{wait} \\
    \end{tabular}
\end{figure}
En cas d'appel système invalide (pour une valeur de \texttt{r0} non renseignée dans le tableau), le noyau n'exécute aucun code, et place la valeur -1 dans \texttt{r0}.

\subsection{Constantes et types OCaml}
On définit les constantes et type OCaml suivant pour représenter notre micro-noyau:
\begin{minted}{ocaml}
let max_time_slices = 5 (* 0 <= t < max_time_slices *)
let max_priority = 15 (* 0 <= p <= max_priority *)
let num_processes = 32
let num_channels = 128
let num_registers = 5

type pid = int (* process id *)
type chanid = int (* channel id *)
type value = int (* values transmitted on channels *)
type interrupt = int (* software interrupt *)
type priority = int (* priority of a process *)

type registers = {
    r0 : int;
    r1 : int;
    r2 : int;
    r3 : int;
    r4 : int; 
}

let get_registers { registers } = {
  r0 = registers.(0); r1 = registers.(1);
  r2 = registers.(2); r3 = registers.(3);
  r4 = registers.(4); }
(* the set of processes ordered by priority *)

let set_registers { registers } { r0; r1; r2; r3; r4 } =
  registers.(0) <- r0; 
  registers.(1) <- r1;
  registers.(2) <- r2; 
  registers.(3) <- r3;
  registers.(4) <- r4
\end{minted}

\noindent On définit ensuite un processus à l'aide du type suivant:

\begin{minted}{ocaml}
type process_state =
    | Free (* non allocated process *)
    | BlockedWriting of chanid
    | BlockedReading of chanid list
    | Waiting
    | Runnable
    | Zombie

type process = {
    mutable parent_id : pid;
    mutable state : process_state;
    mutable slices_left : int;
    saved_context : int array;
}
\end{minted}

\noindent Les états des processus sont décrits par le diagramme ci-dessous:

\noindent On définit par ailleurs un état du noyau à l'aide du type \texttt{state} suivant:
\begin{minted}{ocaml}
type channel_state =
    | Unused (* non allocated channel *)
    | Sender of pid * priority * value
    | Receivers of (pid * priority) list

type state = {              (* kernel state *)
    mutable curr_pid   : pid; (* process id of the running process *)
    mutable curr_prio  : priority; (* its priority *)
    registers  : int array;        (* its registers *)
    processes  : process array;       (* the set of processes *)
    channels   : channel_state array; (* the set of channels *)
    runqueues  : pid list array;
}

let get_current { curr_pid = c } = c
\end{minted}

\noindent Finalement, on définit un évènement, qui peut être soit un \texttt{timer}, soit un appel système:
\begin{minted}{ocaml}
type event = | Timer | SysCall

type syscall =
    | Send of chanid * value
    | Recv of chanid list
    | Fork of priority * value * value * value
    | Wait
    | Exit
    | NewChannel
    | Invalid
\end{minted}

\subsection{Détermination de l'appel système}
Ajoutons une fonction \texttt{decode: state -> syscall} qui décode la valeur des registres et détermine l'appel système.
\begin{minted}{ocaml}
let decode { registers } =
match registers.(0) with
| 0 -> NewChannel
| 1 -> Send (registers.(1), registers.(2))
| 2 -> Recv [registers.(1);
             registers.(2);
             registers.(3);
             registers.(4)]
| 3 -> Fork (registers.(1), registers.(2),
             registers.(3), registers.(4))
| 4 -> Exit
| 5 -> Wait
| _ -> Invalid
\end{minted}

\subsection{Appel système \texttt{fork}}
\paragraph*{Description}
L'appel système \texttt{fork} crée un nouveau processsus fils. Chaque processus est associé à une priorité comprise entre 0 (la plus basse) et 15 (la plus haute). Le registre \texttt{r1} spécifie la priorité du processus créé. 

Si la priorité donnée est strictement plus grande que la priorité du processus qui crée le processus fils, l’appel système se termine sans créer de processus et en plaçant 0 dans \texttt{r0}. Concrètement, un processus de peut pas engendrer un processus de priorité plus élevée que la sienne. 

Si la priorité est valide et qu’un nouveau processus peut être créé, \texttt{r0} reçoit la valeur 1 et \texttt{r1} reçoit le numéro du processus créé. Si un nouveau processus ne peut pas être créé, \texttt{r0} reçoit la valeur 0. Ceci arrive en particulier lorsque le nombre maximum de processus pouvant être créés est égal à \texttt{num\_processes}.

Dans le processus ﬁls créé, \texttt{r0} est initialisé à 1, \texttt{r1} est initialisé au numéro de processus du père (qui a fait l’appel à \texttt{fork}), et les autres registres (\texttt{r2}, \texttt{r3} et \texttt{r4}) sont copiés du processus parent.

\paragraph*{Implémentation} On implémente \texttt{fork} sous la forme d'une fonction de type
\begin{center}
    \texttt{state -> int -> int -> int -> int -> unit}
\end{center}
qui sera appelée sous la forme
\begin{center}
    \texttt{fork state nprio d0 d1 d2}
\end{center}
où \texttt{state} est l'état du système, \texttt{nprio} est la priorité à donner au processus fils, \texttt{d0}, \texttt{d1} et \texttt{d2} sont les valeurs à passer au fils pour initialiser ses trois derniers registres.

\begin{minted}{ocaml}
let fork { curr_pid; curr_prio; registers; processes; runqueues } nprio d0 d1 d2 =
    let rec new_proc i =
        if i >= num_processes then None
        else if processes.(i).state = Free then
            let np = processes.(i) in
            np.parent_id <- curr_pid;
            np.state <- Runnable;
            np.slices_left <- max_time_slices;
            np.saved_context.(0) <- 2;
            np.saved_context.(1) <- curr_pid;
            np.saved_context.(2) <- d0;
            np.saved_context.(3) <- d1;
            np.saved_context.(4) <- d2;
            Some i
        else new_proc (i + 1)
    in
    match new_proc 0 with
    | None -> registers.(0) <- 0
    | Some npid -> begin
            registers.(0) <- 1;
            registers.(1) <- npid;
            runqueues.(nprio) <- runqueues.(nprio) @ [npid]
        end
\end{minted}

\subsection{Appel système \texttt{exit}}
\paragraph*{Description} 
L'appel système \texttt{exit} termine l'exécution du processus l'exécutant. Son argument, la valeur de retour de l'appel, est placé dans le registre \texttt{r1}.

Après appel à \texttt{exit}, le processus entre dans l'état \texttt{Zombie}, et ce jusqu'à l'exécution de l'appel système \texttt{wait} qui récupèrera la valeur de retour.

Si le processus terminé avait des fils, ils devienent \emph{orphelins}. L'identifiant de leur père devient alors le processus 1, appelé \texttt{init}.

\paragraph*{Implémentation} On implémente \texttt{exit} sous la forme d'une fonction de type
\begin{center}
    \texttt{state -> unit}
\end{center}

\begin{minted}{ocaml}
let exit { curr_pid; curr_prio; registers; processes; runqueues } =
    let { parent_id } as p = processes.(curr_pid) in

    (* tous les fils ont maintenant comme père le processus n°1 *)
    let f p = if p.parent_id = curr_pid then p.parent_id <- 1 in
    Array.iter f processes;

    runqueues.(curr_prio) <-
        List.filter (fun pid -> pid <> curr_pid) runqueues.(curr_prio);

    if processes.(parent_id).state = Waiting
    then begin
        processes.(parent_id).state <- Runnable;
        processes.(curr_pid).state <- Free;
        let saved_registers = processes.(parent_id).saved_context in
        saved_registers.(0) <- 1;
        saved_registers.(1) <- curr_pid;
        saved_registers.(2) <- registers.(0)
    end
    else processes.(curr_pid).state <- Zombie
\end{minted}

\subsection{Appel système \texttt{wait}}
\paragraph*{Description} 
Un processus est \emph{en attente} (mode \texttt{Waiting}) jusqu'à ce qu'un de ses fils meurt. S'il ne lui reste plus aucun fils, l'appel système rend la main immédiatement en plaçant 0 dans \texttt{r0}. S'il reste un processus fils dans le mode \texttt{Zombie} ou lorsqu'un fils termine, l'appel à \texttt{wait} termine en plaçant 1 dans \texttt{r0}, l'identifiant du fils dans \texttt{r1} et la valeur de retour de ce fils dans \texttt{r2}. S'il y a plusieurs fils fils dans le mode \texttt{Zombie}, l'un d'eux est choisi arbitrairement.

\paragraph*{Implémentation} On implémente \texttt{wait} sous la forme d'une fonction de type
\begin{center}
    \texttt{state -> bool}
\end{center}
où résultat de \texttt{wait state} est vrai s’il est nécessaire de réordonnancer le processus courant (c’est-à-dire le replacer dans l’état du système et choisir un nouveau processus à ordonnancer).

\begin{minted}{ocaml}
let wait {curr_pid; registers; processes} =
    let rec already_dead has_child i =
        if i = num_processes then has_child, None
        else begin
            let { state; parent_id; saved_context} = processes.(i) in
            if state = Zombie && parent_id = curr_pid
            then true, Some (i, saved_context.(0))
            else already_dead (has_child || parent_id = curr_pid) (i + 1)
        end
    in
    match already_dead false 0 with
    | has_child, None ->
        if has_child
        then (processes.(curr_pid).state <- Waiting; true)
        else (registers.(0) <- 0; false)
    | _, Some (pid, v) ->
        processes.(pid).state <- Free;
        registers.(0) <- 1;
        registers.(1) <- pid;
        registers.(2) <- v;
        false
\end{minted}

\subsection{Appel système \texttt{new\_channel}}
\paragraph*{Description} 
La communication entre processus s’eﬀectue par envoi et écriture dans un canal numéroté, suivant un protocole de \emph{rendez-vous} ("handshake"). L'appel système \texttt{new\_channel} crée donc un nouveau canal. La valeur de retour \texttt{r0} de cet appel système est soit le numéro du canal créé, soit une valeur négative si un nouveau canal n'a pas pu être créé. \texttt{num\_channels} est le nombre maximal de canaux pouvant être créés.

\paragraph*{Implémentation} On implémente \texttt{new\_channel} sous la forme d'une fonction de type
\begin{center}
    \texttt{state -> unit}
\end{center}

\begin{minted}{ocaml}
let new_channel {registers; channels} =
let rec new_channel i =
    if i >= num_channels then -1
    else if channels.(i) = Unused
        then (channels.(i) <- Receivers []; i)
        else new_channel (i + 1)
in
registers.(0) <- new_channel 0
\end{minted}

\end{document}