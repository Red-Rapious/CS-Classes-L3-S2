\documentclass[french, toc]{../cs-classes/cs-classes}

\title{Systèmes d'exploitation}
\author{Timothy Bourke, Marc Pouzet\\ Notes par Antoine Groudiev}
\date{Version du \today}

\begin{document}
\newpage
\section*{Introduction}
Ce document est l'ensemble non officiel des notes du cours \emph{Systèmes d'exploitation} du Département Informatique de l'ENS Ulm. Elles sont librement inspirés des notes de cours sous forme de présentation rédigées par Timothy Bourke et Marc Pouzet.

\section{Micro-noyau}
Commençons ce cours par la programmation d'un micro-noyau fortement simplifié, implémenté en OCaml. Notre objectif sera de retenir l'essentiel d'un noyau de système classique, en exécutant le moins de fonctions possibles en mode super-utilisateur\footnote{Les fonctions exécutées en mode "super-utilisateur" ont un accès non protégé aux ressources.}.

\subsection{Description générale d'un micro-noyau}
Un micro-noyau contient une ou plusieurs \emph{applications}, comme un système de fichier ou un driver de disque.

Les principales fonctionnalités d'un micro-noyau sont de gérer les processus, la communication entre eux, et la mémoire virtuelle. Il doit être capable de créer, arrêter, ordonner les processus en fonction de leur priorité.

On se donne les caractéristiques suivantes pour l'architecture machine:
\begin{itemize}
    \item elle est capable d'exécuter un seul processus à la fois
    \item elle possède cinq registres, de \texttt{r0} à \texttt{r4}
\end{itemize}

\subsection{Appels système}
Le micro-noyau doit être capable de réagir à deux types d'évènements:
\begin{itemize}
    \item l'interruption d'un compteur de temps (\texttt{timer})
    \item des interruptions logicielles (\texttt{system trap} ou \texttt{software interrupt})
\end{itemize}
Les processus de l'utilisateur peuvent changer le contenu des registres et générer des appels système arbitraires. Quand un appel système est déclenché, le micro-noyau lit le contenu des registres pour déterminer l’appel effectué et les arguments de cet appel. Il réagit en effectuant l’appel (par exemple, la mise à jour de l’état du système) et en plaçant les valeurs de retour dans les registres.

On définit les codes d'appels systèmes suivants:
\begin{figure}[!ht]
    \centering
    \begin{tabular}{c c}
        Registre \texttt{r0} & Appel système \\
        \hline
        \texttt{0} & \texttt{new\_channel} \\
        \texttt{1} & \texttt{send} \\
        \texttt{2} & \texttt{receive} \\
        \texttt{3} & \texttt{fork} \\
        \texttt{4} & \texttt{exit} \\
        \texttt{5} & \texttt{wait} \\
    \end{tabular}
\end{figure}
En cas d'appel système invalide (pour une valeur de \texttt{r0} non renseignée dans le tableau), le noyau n'exécute aucun code, et place la valeur -1 dans \texttt{r0}.

\subsection{Constantes et types OCaml}
On définit les constantes et type OCaml suivant pour représenter notre micro-noyau:
\begin{minted}{ocaml}
let max_time_slices = 5 (* 0 <= t < max_time_slices *)
let max_priority = 15 (* 0 <= p <= max_priority *)
let num_processes = 32
let num_channels = 128
let num_registers = 5

type pid = int (* process id *)
type chanid = int (* channel id *)
type value = int (* values transmitted on channels *)
type interrupt = int (* software interrupt *)
type priority = int (* priority of a process *)

type registers = {
    r0 : int;
    r1 : int;
    r2 : int;
    r3 : int;
    r4 : int; 
}

let get_registers { registers } = {
  r0 = registers.(0); r1 = registers.(1);
  r2 = registers.(2); r3 = registers.(3);
  r4 = registers.(4); }
(* the set of processes ordered by priority *)

let set_registers { registers } { r0; r1; r2; r3; r4 } =
  registers.(0) <- r0; 
  registers.(1) <- r1;
  registers.(2) <- r2; 
  registers.(3) <- r3;
  registers.(4) <- r4
\end{minted}

\noindent On définit ensuite un processus à l'aide du type suivant:

\begin{minted}{ocaml}
type process_state =
    | Free (* non allocated process *)
    | BlockedWriting of chanid
    | BlockedReading of chanid list
    | Waiting
    | Runnable
    | Zombie

type process = {
    mutable parent_id : pid;
    mutable state : process_state;
    mutable slices_left : int;
    saved_context : int array;
}
\end{minted}

\noindent Les états des processus sont décrits par le diagramme ci-dessous:

\noindent On définit par ailleurs un état du noyau à l'aide du type \texttt{state} suivant:
\begin{minted}{ocaml}
type channel_state =
    | Unused (* non allocated channel *)
    | Sender of pid * priority * value
    | Receivers of (pid * priority) list

type state = {              (* kernel state *)
    mutable curr_pid   : pid; (* process id of the running process *)
    mutable curr_prio  : priority; (* its priority *)
    registers  : int array;        (* its registers *)
    processes  : process array;       (* the set of processes *)
    channels   : channel_state array; (* the set of channels *)
    runqueues  : pid list array;
}

let get_current { curr_pid = c } = c
\end{minted}

\noindent Finalement, on définit un évènement, qui peut être soit un \texttt{timer}, soit un appel système:
\begin{minted}{ocaml}
type event = | Timer | SysCall

type syscall =
    | Send of chanid * value
    | Recv of chanid list
    | Fork of priority * value * value * value
    | Wait
    | Exit
    | NewChannel
    | Invalid
\end{minted}

\subsection{Détermination de l'appel système}
Ajoutons une fonction \texttt{decode: state -> syscall} qui décode la valeur des registres et détermine l'appel système.
\begin{minted}{ocaml}
let decode { registers } =
match registers.(0) with
| 0 -> NewChannel
| 1 -> Send (registers.(1), registers.(2))
| 2 -> Recv [registers.(1);
             registers.(2);
             registers.(3);
             registers.(4)]
| 3 -> Fork (registers.(1), registers.(2),
             registers.(3), registers.(4))
| 4 -> Exit
| 5 -> Wait
| _ -> Invalid
\end{minted}

\subsection{Appel système \texttt{fork}}
\paragraph*{Description}
L'appel système \texttt{fork} crée un nouveau processsus fils. Chaque processus est associé à une priorité comprise entre 0 (la plus basse) et 15 (la plus haute). Le registre \texttt{r1} spécifie la priorité du processus créé. 

Si la priorité donnée est strictement plus grande que la priorité du processus qui crée le processus fils, l’appel système se termine sans créer de processus et en plaçant 0 dans \texttt{r0}. Concrètement, un processus de peut pas engendrer un processus de priorité plus élevée que la sienne. 

Si la priorité est valide et qu’un nouveau processus peut être créé, \texttt{r0} reçoit la valeur 1 et \texttt{r1} reçoit le numéro du processus créé. Si un nouveau processus ne peut pas être créé, \texttt{r0} reçoit la valeur 0. Ceci arrive en particulier lorsque le nombre maximum de processus pouvant être créés est égal à \texttt{num\_processes}.

Dans le processus ﬁls créé, \texttt{r0} est initialisé à 1, \texttt{r1} est initialisé au numéro de processus du père (qui a fait l’appel à \texttt{fork}), et les autres registres (\texttt{r2}, \texttt{r3} et \texttt{r4}) sont copiés du processus parent.

\paragraph*{Implémentation} On implémente \texttt{fork} sous la forme d'une fonction de type
\begin{center}
    \texttt{state -> int -> int -> int -> int -> unit}
\end{center}
qui sera appelée sous la forme
\begin{center}
    \texttt{fork state nprio d0 d1 d2}
\end{center}
où \texttt{state} est l'état du système, \texttt{nprio} est la priorité à donner au processus fils, \texttt{d0}, \texttt{d1} et \texttt{d2} sont les valeurs à passer au fils pour initialiser ses trois derniers registres.

\begin{minted}{ocaml}
let fork { curr_pid; curr_prio; registers; processes; runqueues } nprio d0 d1 d2 =
    let rec new_proc i =
        if i >= num_processes then None
        else if processes.(i).state = Free then
            let np = processes.(i) in
            np.parent_id <- curr_pid;
            np.state <- Runnable;
            np.slices_left <- max_time_slices;
            np.saved_context.(0) <- 2;
            np.saved_context.(1) <- curr_pid;
            np.saved_context.(2) <- d0;
            np.saved_context.(3) <- d1;
            np.saved_context.(4) <- d2;
            Some i
        else new_proc (i + 1)
    in
    match new_proc 0 with
    | None -> registers.(0) <- 0
    | Some npid -> begin
            registers.(0) <- 1;
            registers.(1) <- npid;
            runqueues.(nprio) <- runqueues.(nprio) @ [npid]
        end
\end{minted}

\end{document}