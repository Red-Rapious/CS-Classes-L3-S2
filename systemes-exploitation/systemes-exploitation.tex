\documentclass[french, toc]{../cs-classes/cs-classes}

\title{Systèmes d'exploitation}
\author{Timothy Bourke, Marc Pouzet\\ Notes par Antoine Groudiev}
\date{Version du \today}

\begin{document}
\newpage
\section*{Introduction}
Ce document est l'ensemble non officiel des notes du cours \emph{Systèmes d'exploitation} du Département Informatique de l'ENS Ulm. Elles sont librement inspirés des notes de cours sous forme de présentation rédigées par Timothy Bourke et Marc Pouzet.

\section{Micro-noyau}
Commençons ce cours par la programmation d'un micro-noyau fortement simplifié, implémenté en OCaml. Notre objectif sera de retenir l'essentiel d'un noyau de système classique, en exécutant le moins de fonctions possibles en mode super-utilisateur\footnote{Les fonctions exécutées en mode "super-utilisateur" ont un accès non protégé aux ressources.}.

\subsection{Description générale d'un micro-noyau}
Un micro-noyau contient une ou plusieurs \emph{applications}, comme un système de fichier ou un driver de disque.

Les principales fonctionnalités d'un micro-noyau sont de gérer les processus, la communication entre eux, et la mémoire virtuelle. Il doit être capable de créer, arrêter, ordonner les processus en fonction de leur priorité.

On se donne les caractéristiques suivantes pour l'architecture machine:
\begin{itemize}
    \item elle est capable d'exécuter un seul processus à la fois
    \item elle possède cinq registres, de \texttt{r0} à \texttt{r4}
\end{itemize}

\subsection{Appels système}
Le micro-noyau doit être capable de réagir à deux types d'évènements:
\begin{itemize}
    \item l'interruption d'un compteur de temps (\texttt{timer})
    \item des interruptions logicielles (\texttt{system trap} ou \texttt{software interrupt})
\end{itemize}
Les processus de l'utilisateur peuvent changer le contenu des registres et générer des appels système arbitraires. Quand un appel système est déclenché, le micro-noyau lit le contenu des registres pour déterminer l’appel effectué et les arguments de cet appel. Il réagit en effectuant l’appel (par exemple, la mise à jour de l’état du système) et en plaçant les valeurs de retour dans les registres.

On définit les codes d'appels systèmes suivants:
\begin{figure}[!ht]
    \centering
    \begin{tabular}{c c}
        Registre \texttt{r0} & Appel système \\
        \hline
        \texttt{0} & \texttt{new\_channel} \\
        \texttt{1} & \texttt{send} \\
        \texttt{2} & \texttt{receive} \\
        \texttt{3} & \texttt{fork} \\
        \texttt{4} & \texttt{exit} \\
        \texttt{5} & \texttt{wait} \\
    \end{tabular}
\end{figure}
En cas d'appel système invalide (pour une valeur de \texttt{r0} non renseignée dans le tableau), le noyau n'exécute aucun code, et place la valeur -1 dans \texttt{r0}.

\subsection{Constantes et types OCaml}
On définit les constantes et type OCaml suivant pour représenter notre micro-noyau:
\begin{minted}{ocaml}
let max_time_slices = 5 (* 0 <= t < max_time_slices *)
let max_priority = 15 (* 0 <= p <= max_priority *)
let num_processes = 32
let num_channels = 128
let num_registers = 5

type pid = int (* process id *)
type chanid = int (* channel id *)
type value = int (* values transmitted on channels *)
type interrupt = int (* software interrupt *)
type priority = int (* priority of a process *)

type registers = {
    r0 : int;
    r1 : int;
    r2 : int;
    r3 : int;
    r4 : int; 
}

let get_registers { registers } = {
  r0 = registers.(0); r1 = registers.(1);
  r2 = registers.(2); r3 = registers.(3);
  r4 = registers.(4); }
(* the set of processes ordered by priority *)

let set_registers { registers } { r0; r1; r2; r3; r4 } =
  registers.(0) <- r0; 
  registers.(1) <- r1;
  registers.(2) <- r2; 
  registers.(3) <- r3;
  registers.(4) <- r4
\end{minted}

\noindent On définit ensuite un processus à l'aide du type suivant:

\begin{minted}{ocaml}
type process_state =
    | Free (* non allocated process *)
    | BlockedWriting of chanid
    | BlockedReading of chanid list
    | Waiting
    | Runnable
    | Zombie

type process = {
    mutable parent_id : pid;
    mutable state : process_state;
    mutable slices_left : int;
    saved_context : int array;
}
\end{minted}

\noindent Les états des processus sont décrits par le diagramme ci-dessous:

\noindent On définit par ailleurs un état du noyau à l'aide du type \texttt{state} suivant:
\begin{minted}{ocaml}
type channel_state =
    | Unused (* non allocated channel *)
    | Sender of pid * priority * value
    | Receivers of (pid * priority) list

type state = {              (* kernel state *)
    mutable curr_pid   : pid; (* process id of the running process *)
    mutable curr_prio  : priority; (* its priority *)
    registers  : int array;        (* its registers *)
    processes  : process array;       (* the set of processes *)
    channels   : channel_state array; (* the set of channels *)
    runqueues  : pid list array;
}

let get_current { curr_pid = c } = c
\end{minted}

\noindent Finalement, on définit un évènement, qui peut être soit un \texttt{timer}, soit un appel système:
\begin{minted}{ocaml}
type event = | Timer | SysCall

type syscall =
    | Send of chanid * value
    | Recv of chanid list
    | Fork of priority * value * value * value
    | Wait
    | Exit
    | NewChannel
    | Invalid
\end{minted}

\end{document}