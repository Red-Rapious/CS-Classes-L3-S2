\documentclass[french, toc]{../cs-classes/cs-classes}

\title{Systèmes d'exploitation}
\author{Timothy Bourke, Marc Pouzet\\ Notes par Antoine Groudiev}
\date{Version du \today}

\begin{document}
\newpage
\section*{Introduction}
Ce document est l'ensemble non officiel des notes du cours \emph{Systèmes d'exploitation} du Département Informatique de l'ENS Ulm. Elles sont librement inspirés des notes de cours sous forme de présentation rédigées par Timothy Bourke et Marc Pouzet.

\section{Micro-noyau}
Commençons ce cours par la programmation d'un micro-noyau fortement simplifié, implémenté en OCaml. Notre objectif sera de retenir l'essentiel d'un noyau de système classique, en exécutant le moins de fonctions possibles en mode super-utilisateur\footnote{Les fonctions exécutées en mode "super-utilisateur" ont un accès non protégé aux ressources.}.

\subsection{Description générale d'un micro-noyau}
Un micro-noyau contient une ou plusieurs \emph{applications}, comme un système de fichier ou un driver de disque.

Les principales fonctionnalités d'un micro-noyau sont de gérer les processus, la communication entre eux, et la mémoire virtuelle. Il doit être capable de créer, arrêter, ordonner les processus en fonction de leur priorité.

On se donne les caractéristiques suivantes pour l'architecture machine:
\begin{itemize}
    \item elle est capable d'exécuter un seul processus à la fois
    \item elle possède cinq registres, de \texttt{r0} à \texttt{r4}
\end{itemize}

\subsection{Appels système}
Le micro-noyau doit être capable de réagir à deux types d'évènements:
\begin{itemize}
    \item l'interruption d'un compteur de temps (\texttt{timer})
    \item des interruptions logicielles (\texttt{system trap} ou \texttt{software interrupt})
\end{itemize}
Les processus de l'utilisateur peuvent changer le contenu des registres et générer des appels système arbitraires. Quand un appel système est déclenché, le micro-noyau lit le contenu des registres pour déterminer l’appel effectué et les arguments de cet appel. Il réagit en effectuant l’appel (par exemple, la mise à jour de l’état du système) et en plaçant les valeurs de retour dans les registres.

On définit les codes d'appels systèmes suivants:
\begin{figure}[!ht]
    \centering
    \begin{tabular}{c c}
        Registre \texttt{r0} & Appel système \\
        \hline
        \texttt{0} & \texttt{new\_channel} \\
        \texttt{1} & \texttt{send} \\
        \texttt{2} & \texttt{receive} \\
        \texttt{3} & \texttt{fork} \\
        \texttt{4} & \texttt{exit} \\
        \texttt{5} & \texttt{wait} \\
    \end{tabular}
\end{figure}
En cas d'appel système invalide (pour une valeur de \texttt{r0} non renseignée dans le tableau), le noyau n'exécute aucun code, et place la valeur -1 dans \texttt{r0}.

\subsection{Constantes et types OCaml}
On définit les constantes et type OCaml suivant pour représenter notre micro-noyau:
\begin{minted}{ocaml}
let max_time_slices = 5 (* 0 <= t < max_time_slices *)
let max_priority = 15 (* 0 <= p <= max_priority *)
let num_processes = 32
let num_channels = 128
let num_registers = 5

type pid = int (* process id *)
type chanid = int (* channel id *)
type value = int (* values transmitted on channels *)
type interrupt = int (* software interrupt *)
type priority = int (* priority of a process *)

type registers = {
r0 : int;
r1 : int;
r2 : int;
r3 : int;
r4 : int; }
\end{minted}

\end{document}